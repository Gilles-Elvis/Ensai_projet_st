---
title: "PROJET : PARCOURS DE SOINS POST-GREFFE RÉNALE"
format: html
editor: visual
---

# PRELIMINAIRES

## Chargement des packages

```{r}
# Installer les packages si nécessaire (décommenter si besoin)
# install.packages("dplyr")
# install.packages("ggplot2")
# install.packages("lubridate")

library(dplyr)
library(ggplot2)
library(lubridate)
library(rvest)
library(stringr)
library(purrr)
```

## Importation des données

```{r}
data = read.csv("donnees.csv", header = TRUE, sep = ";")
View(data)
```

## Vérifier l'importation

```{r}
cat("Nombre de lignes :", nrow(data), "\n")
cat("Nombre de colonnes :", ncol(data), "\n")
```

## Structure des données

```{r}
str(data)
```

```{r}
summary(data)
```

## Variables manquantes

```{r}

est_manquant <- function(x) {
  is.na(x) | (is.character(x) & trimws(x) == "")
}

# Calcul du taux de valeurs manquantes par variable
taux_manquant <- sapply(data, function(col) {
  sum(est_manquant(col)) / length(col) * 100
})

# Dataframe récapitulatif
missing_df <- data.frame(
  variable = names(taux_manquant),
  taux_manquant = taux_manquant
)

# Tri décroissant par taux de valeurs manquantes
missing_df <- missing_df[order(-missing_df$taux_manquant), ]


```

## Conversion des dates

Vu la structure des dates , nous l'avons ramener au format utilisable par R

```{r}
# Extraire la partie date (avant les ":")
# Exemple : "28JUL2022:00:00:00" devient "28JUL2022"
data$date_greffe_clean <- sub(":.*", "", data$date_greffe)
data$debut_sejour_clean <- sub(":.*", "", data$debut_sejour)
data$fin_sejour_clean <- sub(":.*", "", data$fin_sejour)

# Passer en locale anglaise pour reconnaître les mois (JUL, MAR, etc.)
# pas besoin de ça si votre locale est en anglais déjà
Sys.setlocale("LC_TIME", "C")

# Convertir en format Date
data$date_greffe <- as.Date(data$date_greffe_clean, format="%d%b%Y")
data$debut_sejour <- as.Date(data$debut_sejour_clean, format="%d%b%Y")
data$fin_sejour <- as.Date(data$fin_sejour_clean, format="%d%b%Y")
```

## Idenfication du nombre de patients unique

```{r}
nb_patients <- length(unique(data$study_id))
cat("Nombre de patients uniques :", nb_patients, "\n")
```

2784 patients pour 22132 lignes donc il y a des patients qui ont plusieurs séjours

# ANALYSE UNIVARIES

## Structure des données

La base de données est de type longitudinale : chaque ligne correspond à un séjour hospitalier, et un même patient (identifié par `study_id`) peut apparaître plusieurs fois.

Pour les analyses descriptives, une base agrégée au niveau patient (une ligne par patient) est construite en conservant la première greffe observée.


```{r}
data_patients <- data %>%
  group_by(study_id, date_greffe) %>%
  arrange(date_greffe) %>%
  slice(1) %>%
  ungroup() %>%
  mutate(Sexe = factor(COD_SEX, levels = c(1, 2), labels = c("Masculin", "Féminin")))
```

## Distribution de l'âge des patients

```{r}
summary(data_patients$age_greffe)
```

L’âge des patients greffés présente une médiane de 56 ans, proche de la moyenne, indiquant une distribution globalement symétrique.\
La moitié des patients a un âge compris entre environ 44 et 67 ans, ce qui correspond à une population d’adultes d’âge moyen à avancé.

Ci-joint un histogramme pour une meilleure visualisation :

```{r}
ggplot(data_patients, aes(x = age_greffe)) +
geom_histogram(bins = 30, fill = "steelblue", color = "black", alpha = 0.7) +
labs(
title = "Distribution de l'âge des patients à la greffe",
subtitle = paste("n =", nrow(data_patients), "patients"),
x = "Âge (années)",
y = "Nombre de patients"
) +
theme_minimal()
```

Pour la suite de l'étude, nous avons opté pour une rédéfinition des âges en tranches d'âge. Les tranches d’âge ont été définies selon des intervalles de 10 ans à partir de 30 ans, afin de garantir une lecture statistique homogène et de limiter les déséquilibres d’effectifs entre classes. Les seuils retenus (50, 60 et 70 ans) correspondent à des repères épidémiologiques couramment utilisés en transplantation rénale, marquant des évolutions du profil clinique des patients.

Ce choix est également guidé par l’examen de l’histogramme de l’âge, qui met en évidence une forte concentration des patients entre 50 et 70 ans. Les classes extrêmes (\<30 ans et ≥80 ans) ont été regroupées afin d’éviter des effectifs trop faibles et de garantir une interprétation statistique robuste.

```{r}
data_patients$tranche_age <- cut(
data_patients$age_greffe,
breaks = c(0, 30, 40, 50, 60, 70, 80, 120),
labels = c("<30", "30-39", "40-49", "50-59", "60-69", "70-79", "≥80")
)

age_summary <- data_patients %>%
group_by(tranche_age) %>%
summarise(n = n()) %>%
mutate(pourcentage = round(n / sum(n) * 100, 1))

age_summary
```

Pour une meilleure visualisation:

```{r}
ggplot(age_summary, aes(x = tranche_age, y = n)) +
geom_col(fill = "steelblue", color = "black", alpha = 0.8) +
geom_text(
aes(label = paste0(n, " (", pourcentage, "%)")),
vjust = -0.3,
size = 3
) +
labs(
title = "Répartition des patients par tranche d’âge",
x = "Tranche d’âge (années)",
y = "Nombre de patients"
) +
theme_minimal()

```

## Distribution par sexe des patients

```{r}
# Tableau de distribution par sexe
sexe_summary <- data_patients %>%
  group_by(Sexe) %>%
  summarise(
    effectif = n(),
    .groups = "drop"
  ) %>%
  mutate(
    pourcentage = round(effectif / sum(effectif) * 100, 1)
  )

print(sexe_summary)

ggplot(sexe_summary, aes(x = Sexe, y = effectif, fill = Sexe)) +
  geom_col(alpha = 0.8, color = "black") +
  geom_text(
    aes(label = paste0(effectif, " (", pourcentage, "%)")),
    vjust = -0.3,
    size = 4
  ) +
  # coord_cartesian(ylim = c(0, 2000)) +   # 
  labs(
    title = "Répartition des patients greffés par sexe",
    subtitle = paste("n =", nrow(data_patients), "patients"),
    x = "Sexe",
    y = "Nombre de patients"
  ) +
  theme_minimal() +
  theme(legend.position = "none")



```

commentaires.....

## Analyse des séjour post-greffe

### Durée de séjour par patients

On isole d'abord les séjours uniques pour ne pas compter plusieurs fois le même séjour (doublons de lignes)

```{r}
sejours_uniques <- data %>%
  distinct(study_id, ETA_NUM_suivi, RSA_NUM_suivi, debut_sejour, fin_sejour)
```

```{r}
View(sejours_uniques)
```

Calcul de la durée par séjour (avec la règle du 0 -\> 1)

```{r}
Sys.setlocale("LC_TIME", "C")
```

```{r}
sejours_uniques$duree_sejour <- as.numeric(sejours_uniques$fin_sejour - sejours_uniques$debut_sejour)
sejours_uniques$duree_sejour[sejours_uniques$duree_sejour == 0] <- 1
```

Regroupement par patient pour avoir le nombre de séjours ET la durée totale

```{r}
bilan_par_patient <- sejours_uniques %>%
  group_by(study_id) %>%
  summarise(
    nb_sejours = n(),                    # Nombre de séjours uniques
    duree_totale_cumulee = sum(duree_sejour, na.rm = TRUE) # Somme des durées
  ) %>%
  ungroup()
```

Affichage des résultats

```{r}
cat("\nRésumé de la durée totale de séjour par patient :\n")
print(summary(bilan_par_patient$duree_totale_cumulee))

cat("\nRésumé du nombre de séjours par patient :\n")
print(summary(bilan_par_patient$nb_sejours))
```

Dans les préliminaires , nous avons constater que les patients peuvent avoir plusieurs séjours , nous avons décidé de vérifier le nombre exacte de séjour par patients

D'abord nous regardons la durée de séjour par ligne dans la base de données avant de faire le regroupement par patient

```{r}
data$duree_sejour <- as.numeric(data$fin_sejour - data$debut_sejour)
data$duree_sejour[data$duree_sejour == 0] <- 1
```

Remarquons que lorsque la durée du séjour fait 0, nous l'initialisons à 1 afin d'avoir une bonne représentativité vu l'opération mathématique qui est réalisée.

Nous groupons maintenant par patient:

```{r}
sejours_par_patient <- data %>%
  group_by(study_id) %>%
  summarise(nb_sejours = n()) %>%
  ungroup()

cat("\nNombre de séjours par patient :\n")
print(summary(sejours_par_patient$nb_sejours))
```

Hétérogénéité majeure : De 1 à 3 101 séjours !

25% avec peu de suivi (1-2 séjours)

50% avec suivi standard (2-7 séjours)

25% avec suivi intensif (\>7 séjours)

La médiane (4) est plus représentative que la moyenne (7.95)

### Graphiquement

```{r}
dist_sejours <- table(table(data$study_id))

barplot(
  dist_sejours,
  xlab = "Nombre de séjours par patient",
  ylab = "Nombre de patients",
  main = "Distribution du nombre de séjours par patient",
  col = "steelblue"
)
```

401 patients ont 1 seul séjour (probablement juste la greffe, sans réhospitalisation) ligne de code 102

436 patients ont 2 séjours \# La majorité des patients ont entre 1 et 10 séjours

Quelques patients ont un suivi très intensif : jusqu'à 3101 séjours pour un patient !

### Densité des séjours

```{r}
# # Délai entre greffe et début du séjour de suivi (en jours)
data$delai_greffe_suivi <- as.numeric(data$debut_sejour - data$date_greffe)

# Durée du séjour de suivi (en jours)
data$duree_sejour <- as.numeric(data$fin_sejour - data$debut_sejour)

# Distribution temporelle des séjours de suivi
delais_tranches <- table(cut(data$delai_greffe_suivi, 
                             breaks = c( 0, 7, 30, 90, 180, 365, Inf),
                             labels = c("0-7j", "8-30j", "1-3mois", 
                                        "3-6mois", "6-12mois", ">12mois")))
cat("\nDistribution temporelle des séjours de suivi :\n")
print(delais_tranches)
cat("\nPourcentages :\n")
print(round(prop.table(delais_tranches) * 100, 1))


# Graphiquement :

df_plot <- as.data.frame(delais_tranches)
colnames(df_plot) <- c("classe_delai", "nb_sejours")

# Forcer l’ordre logique des classes
df_plot$classe_delai <- factor(
  df_plot$classe_delai,
  levels = c("Négatif", "0-7j", "8-30j", "1-3mois",
             "3-6mois", "6-12mois", ">12mois")
)

ggplot(df_plot, aes(x = classe_delai, y = nb_sejours)) +
  geom_col(fill = "steelblue") +
  labs(
    title = "Distribution temporelle des séjours de suivi",
    x = "séjour de suivi",
    y = "Nombre de séjours"
  ) +
  theme_minimal()
```

Concentration majeure entre 1 et 6 mois

Le pic principal se situe dans la classe 1–3 mois, qui regroupe le plus grand nombre de séjours.

Les classes 3–6 mois et 8–30 jours présentent également des effectifs élevés.

Cela traduit une intensité du suivi dans les premiers mois post-greffe, période critique sur le plan médical.

Suivi précoce mais non immédiat

Les séjours dans les 0–7 jours sont relativement peu nombreux comparés aux classes suivantes.

Le suivi immédiat post-greffe semble moins fréquent dans cette base, ou bien géré dans un autre cadre (hospitalisation initiale).

Diminution progressive à long terme

Les séjours entre 6–12 mois sont encore présents mais en baisse. \# Les séjours à plus de 12 mois sont très rares. \# Le suivi devient plus espacé à mesure que le temps depuis la greffe augmente. \# conclusion chat \# La distribution temporelle des séjours de suivi met en évidence une forte concentration \# des consultations dans les premiers mois suivant la greffe, avec un pic marqué entre 1 et 3 mois. \# Cette dynamique est cohérente avec les protocoles de suivi intensif post-greffe. \# Les séjours à plus long terme deviennent progressivement moins fréquents, \# traduisant un espacement du suivi pour les patients stabilisés.

## Nombre de greffe par patients

```{r}
greffes_par_patient <- data %>%
  distinct(study_id, date_greffe, RSA_NUM_suivi) %>%
  group_by(study_id) %>%
  summarise(nb_greffes = n()) %>%
  ungroup()

cat("\nNombre de greffes par patient :\n")
print(table(greffes_par_patient$nb_greffes))
```

## Distribution du nombre de greffe par mois

```{r}
# Distribution temporelle des greffes
data_patients$mois_greffe <- format(data_patients$date_greffe, "%Y-%m")

# Créer variables mois et année
data_patients$annee <- format(data_patients$date_greffe, "%Y")
data_patients$mois_num <- format(data_patients$date_greffe, "%m")

# Calculer le nombre par mois et année
greffes_heatmap <- data_patients %>%
  mutate(mois = as.Date(format(date_greffe, "%Y-%m-01"))) %>%
  group_by(mois) %>%
  summarise(nb_greffes = n(), .groups = "drop")


# Graphiquement
ggplot(greffes_heatmap, aes(x = mois, y = nb_greffes)) +
  geom_col(fill = "lightblue", color = "black", alpha = 0.7) +
  labs(
    title = "Évolution mensuelle du nombre de greffes rénales",
    x = "Date",
    y = "Nombre de greffes"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 14))


```

-   Après un **niveau très faible en début de période**, le nombre mensuel de greffes augmente rapidement.

    L’activité se stabilise ensuite autour d’un **plateau compris approximativement entre 200 et 300 greffes par mois**.

    Une **baisse en fin de période** est visible.(liée à une période incomplète de collecte des donnée? ou vrai dimunition)

## Top 10 des diagnostics principaux chez les patients

```{r}
# Préparation des données
top_dgn_pal <- sort(table(data_patients$DGN_PAL), decreasing = TRUE)[1:10]
df_dgn <- data.frame(
  diagnostic = names(top_dgn_pal),
  nombre = as.numeric(top_dgn_pal)
)

# Calculer les pourcentages
df_dgn$pourcentage <- round(df_dgn$nombre / nrow(data_patients) * 100, 1)

# Réordonner pour le graphique (du plus fréquent au moins fréquent)
df_dgn$diagnostic <- factor(df_dgn$diagnostic, 
                            levels = df_dgn$diagnostic)


# Graphiquement 
ggplot(df_dgn, aes(x = reorder(diagnostic, nombre), y = nombre)) +
  geom_bar(stat = "identity", fill = "steelblue", color = "black") +
  geom_text(aes(label = paste0(nombre, " (", pourcentage, "%)")), 
            hjust = -0.1, size = 3.5) +
  coord_flip() +
  labs(title = "Top 10 des diagnostics principaux à la greffe",
       subtitle = "Nombre de patients et pourcentage",
       x = "Code diagnostic (CIM-10)",
       y = "Nombre de patients") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 14)) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15)))
```

On a besoin de connaitre la signification des codes pour savoir quelle interprétation donnée

## Top 10 des dignostics relié à la greffe

```{r}
top_dgn_rel <- sort(table(data_patients$DGN_REL), decreasing = TRUE)[1:10]
df_dgn_rel <- data.frame(
  diagnostic = names(top_dgn_rel),
  nombre = as.numeric(top_dgn_rel)
)

# Calculer les pourcentages
df_dgn_rel$pourcentage <- round(df_dgn_rel$nombre / nrow(data_patients) * 100, 1)

# Graphquement
ggplot(df_dgn_rel, aes(x = reorder(diagnostic, nombre), y = nombre)) +
  geom_bar(stat = "identity", fill = "coral", color = "black") +
  geom_text(aes(label = paste0(nombre, " (", pourcentage, "%)")), 
            hjust = -0.1, size = 3.5, fontface = "bold") +
  coord_flip() +
  labs(title = "Top 10 des diagnostics reliés à la greffe",
       subtitle = paste("n =", nrow(data_patients), "patients"),
       x = "Code diagnostic relié (CIM-10)",
       y = "Nombre de patients") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 14),
        panel.grid.major.y = element_blank()) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15)))
```

Idem , on ne peut pas dire grand chose( code vide==XXXX ? )

## Top 10 des établissement qui font plus de greffe

```{r}
# Préparer les données
top_eta <- sort(table(data_patients$ETA_NUM), decreasing = TRUE)[1:10]
df_eta <- data.frame(
  etablissement = names(top_eta),
  nombre = as.numeric(top_eta)
)

# Calculer les pourcentages
df_eta$pourcentage <- round(df_eta$nombre / nrow(data_patients) * 100, 1)

# Calculer le nombre total d'établissements
nb_etablissements <- length(unique(data_patients$ETA_NUM))

# Calculer la part des "autres" établissements
nb_top10 <- sum(df_eta$nombre)
nb_autres <- nrow(data_patients) - nb_top10


# GRAPHIQUE : Barplot horizontal avec pourcentages

ggplot(df_eta, aes(x = reorder(etablissement, nombre), y = nombre)) +
  geom_bar(stat = "identity", fill = "darkgreen", color = "black", alpha = 0.8) +
  geom_text(aes(label = paste0(nombre, " (", pourcentage, "%)")), 
            hjust = -0.1, size = 3.5, fontface = "bold") +
  coord_flip() +
  labs(title = "Top 10 des établissements réalisant des greffes rénales",
       subtitle = paste("Sur", nb_etablissements, "établissements au total |",
                        nrow(data_patients), "patients greffés"),
       x = "Code établissement",
       y = "Nombre de greffes réalisées") +
  theme_minimal() +
  theme(plot.title = element_text(face = "bold", size = 13),
        plot.subtitle = element_text(size = 10),
        panel.grid.major.y = element_blank()) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15)))
```

Concentration extrême sur UN établissement :

750712184 : 528 greffes (19% du total) → Centre ultra-dominant

Presque 3x plus que le 2ème établissement \#

À lui seul = autant que les 7 suivants réunis

Distribution des autres centres :

2ème rang (330781196) : 188 greffes (6.8%) → Écart énorme avec le 1er

3ème au 10ème rang : entre 102 et 180 greffes (3.7% à 6.5%)

Distribution relativement homogène entre eux (pas de 2ème "super-centre")

Activité des 10 premiers :

Total Top 10 : ≈ 1753 greffes

\% du total : 1753/2784 = 63% des greffes réalisées par 10 centres sur 30

20 autres centres se partagent seulement 37% de l'activité

ANALYSE GÉOGRAPHIQUE DES GREFFES PAR DÉPARTEMENT

```{r}


# ==============================================================================
# ÉTAPE 1 : Extraire les départements des codes établissements
# ==============================================================================

# Extraire les 2 premiers chiffres du code ETA_NUM
data_patients <- data_patients %>%
  mutate(
    # Convertir en caractère si nécessaire
    ETA_NUM_char = as.character(ETA_NUM),
    # Extraire les 2 premiers chiffres
    code_dept = substr(ETA_NUM_char, 1, 2),
    # Créer un nom de département plus lisible
    departement = paste0("Dép. ", code_dept)
  )

# Vérifier l'extraction
cat("=== VÉRIFICATION EXTRACTION DÉPARTEMENTS ===\n")
cat("Nombre de départements distincts :", 
    length(unique(data_patients$code_dept)), "\n\n")

# Afficher quelques exemples
exemples <- data_patients %>%
  select(ETA_NUM, code_dept, departement) %>%
  distinct() %>%
  head(10)

cat("Exemples d'extraction :\n")
print(exemples)

# Distribution des départements
cat("\n=== DISTRIBUTION PAR DÉPARTEMENT ===\n")
dept_distribution <- sort(table(data_patients$code_dept), decreasing = TRUE)
print(head(dept_distribution, 15))

# ==============================================================================
# ÉTAPE 2 : Analyse par département (au lieu d'établissement)
# ==============================================================================

# Compter les greffes par département
greffes_par_dept <- data_patients %>%
  group_by(code_dept, departement) %>%
  summarise(
    nb_greffes = n(),
    nb_etablissements = n_distinct(ETA_NUM)
  ) %>%
  ungroup() %>%
  arrange(desc(nb_greffes)) %>%
  mutate(
    pourcentage = round(nb_greffes / sum(nb_greffes) * 100, 1),
    pct_cumule = cumsum(nb_greffes) / sum(nb_greffes) * 100
  )

# Afficher le top 10
cat("\n=== TOP 10 DÉPARTEMENTS ===\n")
print(head(greffes_par_dept, 10))

# ==============================================================================
# GRAPHIQUE 1 : Top 10 départements
# ==============================================================================

top10_dept <- head(greffes_par_dept, 10)

ggplot(top10_dept, aes(x = reorder(departement, nb_greffes), y = nb_greffes)) +
  geom_bar(stat = "identity", fill = "darkgreen", color = "black", alpha = 0.8) +
  geom_text(aes(label = paste0(nb_greffes, " (", pourcentage, "%)\n",
                                nb_etablissements, " étab.")), 
            hjust = -0.1, size = 3, fontface = "bold") +
  coord_flip() +
  labs(
    title = "Top 10 des départements réalisant des greffes rénales",
    subtitle = paste("Sur", nrow(greffes_par_dept), "départements |",
                     sum(greffes_par_dept$nb_greffes), "patients greffés"),
    x = "Département",
    y = "Nombre de greffes réalisées",
    caption = "Note : Nombre d'établissements par département indiqué"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 13),
    plot.subtitle = element_text(size = 10),
    panel.grid.major.y = element_blank()
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.2)))

ggsave("fig_top10_departements.png", width = 12, height = 8, dpi = 300)


```

ygzehbchjbsdj

```{r}

# ==============================================================================
# RÉFÉRENTIEL DÉPARTEMENTS FRANÇAIS
# ==============================================================================

# Créer la table de correspondance code → nom département
ref_departements <- data.frame(
  code_dept = c(
    "01", "02", "03", "04", "05", "06", "07", "08", "09", "10",
    "11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
    "21", "22", "23", "24", "25", "26", "27", "28", "29", "30",
    "31", "32", "33", "34", "35", "36", "37", "38", "39", "40",
    "41", "42", "43", "44", "45", "46", "47", "48", "49", "50",
    "51", "52", "53", "54", "55", "56", "57", "58", "59", "60",
    "61", "62", "63", "64", "65", "66", "67", "68", "69", "70",
    "71", "72", "73", "74", "75", "76", "77", "78", "79", "80",
    "81", "82", "83", "84", "85", "86", "87", "88", "89", "90",
    "91", "92", "93", "94", "95",
    "2A", "2B",  # Corse
    "971", "972", "973", "974", "976"  # DOM
  ),
  nom_dept = c(
    "Ain", "Aisne", "Allier", "Alpes-de-Haute-Provence", "Hautes-Alpes",
    "Alpes-Maritimes", "Ardèche", "Ardennes", "Ariège", "Aube",
    "Aude", "Aveyron", "Bouches-du-Rhône", "Calvados", "Cantal",
    "Charente", "Charente-Maritime", "Cher", "Corrèze", "Corse",
    "Côte-d'Or", "Côtes-d'Armor", "Creuse", "Dordogne", "Doubs",
    "Drôme", "Eure", "Eure-et-Loir", "Finistère", "Gard",
    "Haute-Garonne", "Gers", "Gironde", "Hérault", "Ille-et-Vilaine",
    "Indre", "Indre-et-Loire", "Isère", "Jura", "Landes",
    "Loir-et-Cher", "Loire", "Haute-Loire", "Loire-Atlantique", "Loiret",
    "Lot", "Lot-et-Garonne", "Lozère", "Maine-et-Loire", "Manche",
    "Marne", "Haute-Marne", "Mayenne", "Meurthe-et-Moselle", "Meuse",
    "Morbihan", "Moselle", "Nièvre", "Nord", "Oise",
    "Orne", "Pas-de-Calais", "Puy-de-Dôme", "Pyrénées-Atlantiques", "Hautes-Pyrénées",
    "Pyrénées-Orientales", "Bas-Rhin", "Haut-Rhin", "Rhône", "Haute-Saône",
    "Saône-et-Loire", "Sarthe", "Savoie", "Haute-Savoie", "Paris",
    "Seine-Maritime", "Seine-et-Marne", "Yvelines", "Deux-Sèvres", "Somme",
    "Tarn", "Tarn-et-Garonne", "Var", "Vaucluse", "Vendée",
    "Vienne", "Haute-Vienne", "Vosges", "Yonne", "Territoire de Belfort",
    "Essonne", "Hauts-de-Seine", "Seine-Saint-Denis", "Val-de-Marne", "Val-d'Oise",
    "Corse-du-Sud", "Haute-Corse",
    "Guadeloupe", "Martinique", "Guyane", "La Réunion", "Mayotte"
  ),
  region = c(
    "Auvergne-Rhône-Alpes", "Hauts-de-France", "Auvergne-Rhône-Alpes", "Provence-Alpes-Côte d'Azur", "Provence-Alpes-Côte d'Azur",
    "Provence-Alpes-Côte d'Azur", "Auvergne-Rhône-Alpes", "Grand Est", "Occitanie", "Grand Est",
    "Occitanie", "Occitanie", "Provence-Alpes-Côte d'Azur", "Normandie", "Auvergne-Rhône-Alpes",
    "Nouvelle-Aquitaine", "Nouvelle-Aquitaine", "Centre-Val de Loire", "Nouvelle-Aquitaine", "Corse",
    "Bourgogne-Franche-Comté", "Bretagne", "Nouvelle-Aquitaine", "Nouvelle-Aquitaine", "Bourgogne-Franche-Comté",
    "Auvergne-Rhône-Alpes", "Normandie", "Centre-Val de Loire", "Bretagne", "Occitanie",
    "Occitanie", "Occitanie", "Nouvelle-Aquitaine", "Occitanie", "Bretagne",
    "Centre-Val de Loire", "Centre-Val de Loire", "Auvergne-Rhône-Alpes", "Bourgogne-Franche-Comté", "Nouvelle-Aquitaine",
    "Centre-Val de Loire", "Auvergne-Rhône-Alpes", "Auvergne-Rhône-Alpes", "Pays de la Loire", "Centre-Val de Loire",
    "Occitanie", "Nouvelle-Aquitaine", "Occitanie", "Pays de la Loire", "Normandie",
    "Grand Est", "Grand Est", "Pays de la Loire", "Grand Est", "Grand Est",
    "Bretagne", "Grand Est", "Bourgogne-Franche-Comté", "Hauts-de-France", "Hauts-de-France",
    "Normandie", "Hauts-de-France", "Auvergne-Rhône-Alpes", "Nouvelle-Aquitaine", "Occitanie",
    "Occitanie", "Grand Est", "Grand Est", "Auvergne-Rhône-Alpes", "Bourgogne-Franche-Comté",
    "Bourgogne-Franche-Comté", "Pays de la Loire", "Auvergne-Rhône-Alpes", "Auvergne-Rhône-Alpes", "Île-de-France",
    "Normandie", "Île-de-France", "Île-de-France", "Nouvelle-Aquitaine", "Hauts-de-France",
    "Occitanie", "Occitanie", "Provence-Alpes-Côte d'Azur", "Provence-Alpes-Côte d'Azur", "Pays de la Loire",
    "Nouvelle-Aquitaine", "Nouvelle-Aquitaine", "Grand Est", "Bourgogne-Franche-Comté", "Bourgogne-Franche-Comté",
    "Île-de-France", "Île-de-France", "Île-de-France", "Île-de-France", "Île-de-France",
    "Corse", "Corse",
    "Guadeloupe", "Martinique", "Guyane", "La Réunion", "Mayotte"
  ),
  stringsAsFactors = FALSE
)

# Afficher le référentiel
cat("=== RÉFÉRENTIEL DÉPARTEMENTS ===\n")
cat("Nombre de départements :", nrow(ref_departements), "\n\n")
print(head(ref_departements, 10))

# ==============================================================================
# ÉTAPE 1 : Extraire les codes départements et joindre les noms
# ==============================================================================

data_patients <- data_patients %>%
  mutate(
    ETA_NUM_char = as.character(ETA_NUM),
    code_dept = substr(ETA_NUM_char, 1, 2)
  ) %>%
  # Jointure avec le référentiel
  left_join(ref_departements, by = "code_dept")

# Vérifier la jointure
verif_jointure <- data_patients %>%
  group_by(code_dept, nom_dept, region) %>%
  summarise(nb_patients = n()) %>%
  ungroup() %>%
  arrange(desc(nb_patients))

cat("\n=== VÉRIFICATION JOINTURE ===\n")
cat("Départements avec nom :", sum(!is.na(verif_jointure$nom_dept)), "\n")
cat("Départements sans nom (à vérifier) :", sum(is.na(verif_jointure$nom_dept)), "\n\n")

# Afficher les départements sans nom (codes non reconnus)
if (sum(is.na(verif_jointure$nom_dept)) > 0) {
  cat("Codes non reconnus :\n")
  print(verif_jointure %>% filter(is.na(nom_dept)))
}

# ==============================================================================
# ÉTAPE 2 : Analyse par département avec noms
# ==============================================================================

greffes_par_dept <- data_patients %>%
  filter(!is.na(nom_dept)) %>%  # Exclure les codes non reconnus
  group_by(code_dept, nom_dept, region) %>%
  summarise(
    nb_greffes = n(),
    nb_etablissements = n_distinct(ETA_NUM)
  ) %>%
  ungroup() %>%
  arrange(desc(nb_greffes)) %>%
  mutate(
    pourcentage = round(nb_greffes / sum(nb_greffes) * 100, 1),
    pct_cumule = cumsum(nb_greffes) / sum(nb_greffes) * 100,
    # Créer un label complet
    dept_label = paste0(nom_dept, " (", code_dept, ")")
  )

# Afficher le top 15
cat("\n=== TOP 15 DÉPARTEMENTS ===\n")
print(head(greffes_par_dept, 15))

# ==============================================================================
# GRAPHIQUE 1 : Top 10 départements avec NOMS
# ==============================================================================

top10_dept <- head(greffes_par_dept, 10)

ggplot(top10_dept, aes(x = reorder(dept_label, nb_greffes), y = nb_greffes)) +
  geom_bar(stat = "identity", fill = "darkgreen", color = "black", alpha = 0.8) +
  geom_text(aes(label = paste0(nb_greffes, " (", pourcentage, "%)\n",
                                nb_etablissements, " étab.")), 
            hjust = -0.1, size = 3.2, fontface = "bold") +
  coord_flip() +
  labs(
    title = "Top 10 des départements réalisant des greffes rénales",
    subtitle = paste("Sur", nrow(greffes_par_dept), "départements |",
                     sum(greffes_par_dept$nb_greffes), "patients greffés"),
    x = "Département",
    y = "Nombre de greffes réalisées",
    caption = "Note : Nombre d'établissements par département indiqué"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 10),
    axis.text.y = element_text(size = 10),
    panel.grid.major.y = element_blank()
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.2)))

ggsave("fig_top10_departements_noms.png", width = 12, height = 8, dpi = 300)


```

gcghvjhbvj,h

```{r}
# ==============================================================================
# GRAPHIQUE 2 : Top 15 départements (version plus large)
# ==============================================================================

top15_dept <- head(greffes_par_dept, 15)

ggplot(top15_dept, aes(x = reorder(nom_dept, nb_greffes), y = nb_greffes)) +
  geom_bar(stat = "identity", fill = "darkgreen", color = "black", alpha = 0.8) +
  geom_text(aes(label = paste0(nb_greffes, " (", pourcentage, "%)")), 
            hjust = -0.1, size = 3, fontface = "bold") +
  coord_flip() +
  labs(
    title = "Top 15 des départements réalisant des greffes rénales",
    subtitle = paste(sum(top15_dept$nb_greffes), "greffes |",
                     round(sum(top15_dept$pourcentage), 1), "% du total national"),
    x = "Département",
    y = "Nombre de greffes réalisées"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    plot.subtitle = element_text(size = 10),
    axis.text.y = element_text(size = 9),
    panel.grid.major.y = element_blank()
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15)))

ggsave("fig_top15_departements.png", width = 12, height = 10, dpi = 300)


```

gfgvhjb,jbj,

```{r}
# ==============================================================================
# GRAPHIQUE 3 : Par région (regroupement)
# ==============================================================================

greffes_par_region <- data_patients %>%
  filter(!is.na(region)) %>%
  group_by(region) %>%
  summarise(
    nb_greffes = n(),
    nb_departements = n_distinct(code_dept),
    nb_etablissements = n_distinct(ETA_NUM)
  ) %>%
  ungroup() %>%
  arrange(desc(nb_greffes)) %>%
  mutate(
    pourcentage = round(nb_greffes / sum(nb_greffes) * 100, 1)
  )

cat("\n=== GREFFES PAR RÉGION ===\n")
print(greffes_par_region)

ggplot(greffes_par_region, aes(x = reorder(region, nb_greffes), y = nb_greffes)) +
  geom_bar(stat = "identity", fill = "steelblue", color = "black", alpha = 0.8) +
  geom_text(aes(label = paste0(nb_greffes, " (", pourcentage, "%)")), 
            hjust = -0.1, size = 3.5, fontface = "bold") +
  coord_flip() +
  labs(
    title = "Répartition des greffes rénales par région",
    subtitle = paste(nrow(greffes_par_region), "régions |",
                     sum(greffes_par_region$nb_greffes), "greffes"),
    x = "Région",
    y = "Nombre de greffes réalisées"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 14),
    axis.text.y = element_text(size = 10),
    panel.grid.major.y = element_blank()
  ) +
  scale_y_continuous(expand = expansion(mult = c(0, 0.15)))

ggsave("fig_greffes_par_region.png", width = 12, height = 8, dpi = 300)


```

gchjvhj

```{r}
# ==============================================================================
# GRAPHIQUE 4 : Heatmap Région x Département (Top régions)
# ==============================================================================

# Top 5 régions
top_regions <- head(greffes_par_region$region, 5)

greffes_region_dept <- data_patients %>%
  filter(region %in% top_regions, !is.na(nom_dept)) %>%
  group_by(region, nom_dept) %>%
  summarise(nb_greffes = n()) %>%
  ungroup()

ggplot(greffes_region_dept, aes(x = region, y = nom_dept, fill = nb_greffes)) +
  geom_tile(color = "white", size = 0.5) +
  geom_text(aes(label = nb_greffes), color = "white", fontface = "bold", size = 3) +
  scale_fill_gradient(low = "lightgreen", high = "darkgreen", name = "Nb greffes") +
  labs(
    title = "Nombre de greffes par département dans les 5 principales régions",
    x = "Région",
    y = "Département"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 12),
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
    axis.text.y = element_text(size = 8),
    panel.grid = element_blank()
  )

ggsave("fig_heatmap_region_dept.png", width = 12, height = 10, dpi = 300)


```

hj,b,b,

```{r}
################################################################################
# GRAPHIQUE BONUS : Treemap des départements
################################################################################

library(treemap)

# Préparer les données pour treemap
data_treemap <- greffes_par_dept %>%
  head(20) %>%
  mutate(
    label = paste0(nom_dept, "\n", nb_greffes, " greffes\n(", pourcentage, "%)")
  )

treemap(data_treemap,
        index = c("region", "nom_dept"),
        vSize = "nb_greffes",
        vColor = "nb_greffes",
        type = "value",
        palette = "Greens",
        title = "Répartition géographique des greffes rénales (Top 20 départements)",
        fontsize.title = 14,
        fontsize.labels = c(12, 10),
        fontface.labels = c(2, 1),
        align.labels = list(c("center", "center"), c("left", "top")),
        border.col = "white",
        border.lwds = c(3, 1))
```

v b bn bn

```{r}
library(sf)
library(ggplot2)
library(dplyr)

# Carte des départements français
departements <- st_read(
  "https://france-geojson.gregoiredavid.fr/repo/departements.geojson",
  quiet = TRUE
)

```

```{r}
greffes_par_dept <- greffes_par_dept %>%
  mutate(code_dept = as.character(code_dept))

```

```{r}
carte_greffes <- departements %>%
  left_join(greffes_par_dept, by = c("code" = "code_dept"))

```

```{r}
ggplot(carte_greffes) +
  geom_sf(aes(fill = nb_greffes), color = "white", linewidth = 0.2) +
  scale_fill_viridis_c(
    option = "C",
    na.value = "grey90",
    name = "Nombre de greffes"
  ) +
  labs(
    title = "Répartition géographique des greffes rénales en France",
    subtitle = "Par département",
    caption = "Source : données hospitalières"
  ) +
  theme_minimal()

```

```{r}
summary(carte_greffes$nb_greffes)

```

Par région

```{r}
regions <- st_read(
  "https://france-geojson.gregoiredavid.fr/repo/regions.geojson",
  quiet = TRUE
)
```

```{r}
regions_metro <- regions %>%
  filter(!nom %in% c(
    "Guadeloupe", "Martinique", "Guyane",
    "La Réunion", "Mayotte"
  ))


```

```{r}
carte_regions <- regions_metro %>%
  left_join(
    greffes_par_region,
    by = c("nom" = "region")
  )


```

```{r}
ggplot(carte_regions) +
  geom_sf(aes(fill = nb_greffes), color = "white", linewidth = 0.3) +
  scale_fill_viridis_c(
    option = "C",
    na.value = "grey90",
    name = "Nombre de greffes"
  ) +
  labs(
    title = "Répartition régionale des greffes rénales en France",
    subtitle = "France métropolitaine",
    caption = "Source : données hospitalières"
  ) +
  theme_minimal()


```

gvvvvnvbnh


```{r}
ggplot(carte_regions) +
  geom_sf(aes(fill = nb_greffes), color = "white", linewidth = 0.3) +
  geom_sf_text(
    aes(label = nb_greffes),
    size = 3,
    fontface = "bold",
    color = "black"
  ) +
  scale_fill_viridis_c(
    option = "C",
    name = "Nombre de greffes"
  ) +
  labs(
    title = "Répartition régionale des greffes rénales en France",
    subtitle = "Agrégation par région",
    caption = "Source : données hospitalières"
  ) +
  theme_minimal()

```


```{r}
## Récupération de la liste des diagnostics généraux 
liste_dgn_pal <- unique(data$DGN_PAL)
print(liste_dgn_pal)
```


Pour une meilleure visualisation :

```{r}
obtenir_top_diagnostics <- function(data, n = 10) {
  resultat <- data %>%
    count(DGN_PAL_suivi, name = "Occurrences") %>%  
    arrange(desc(Occurrences)) %>%           
    slice_head(n = n)                        
  
  return(resultat)
}
```

```{r}
top5 <- obtenir_top_diagnostics(data, n = 7)
print(top5)
```



Nous avons décidé de créer une fonction qui va nous retourner directement le nom des diagnostics 


```{r}
obtenir_diagnostics_avec_noms <- function(data, n = 10) {
  
  # 1. Calculer les occurrences
  top_diagnostics <- data %>%
    count(DGN_PAL_suivi, name = "Occurrences") %>%
    arrange(desc(Occurrences)) %>%
    slice_head(n = n)
  
  # 2. Fonction interne pour aller chercher la définition sur le site
  recuperer_definition <- function(code) {
    # On gère le cas particulier RSSABS qui n'est pas un code CIM standard
    if (code == "RSSABS") return("Résumé de sortie standardisé - Absence de diagnostic")
    
    # Construction de l'URL
    url <- paste0("https://www.aideaucodage.fr/cim-", code)
    
    tryCatch({
      # Lecture de la page web
      page <- read_html(url)
      
      # Extraction du titre (généralement le format est "Code - Définition")
      titre <- page %>% html_element("h1") %>% html_text(trim = TRUE)
      
      # Nettoyage : On enlève le code du titre pour ne garder que le texte
      definition <- str_remove(titre, paste0("^", code, " - "))
      return(definition)
    }, error = function(e) {
      return("Définition non trouvée")
    })
  }
  
  # 3. Appliquer la recherche à chaque ligne (Attention: cela peut prendre quelques secondes)
  cat("Recherche des définitions sur aideaucodage.fr...\n")
  top_diagnostics <- top_diagnostics %>%
    rowwise() %>%
    mutate(Signification = recuperer_definition(DGN_PAL_suivi)) %>%
    ungroup()
  
  return(top_diagnostics)
}
```


```{r}
resultat <- obtenir_diagnostics_avec_noms(data, 10)
print(resultat)
```

# ANALYSE BIVARIEES

## Durée de séjour par sexe

Nous allons joindre l'information du sexe (présente dans `data_patients`) à notre décompte de séjours.

```{r}
sejours_sexe <- bilan_par_patient %>%
  left_join(data_patients %>% select(study_id, Sexe), by = "study_id")

head(sejours_sexe)
```

```{r}
summary_sejours_sexe <- sejours_sexe %>%
  group_by(Sexe) %>%
  summarise(
    n_patients = n(),
    moyenne = round(mean(duree_totale_cumulee), 2),
    mediane = median(duree_totale_cumulee),
    ecart_type = round(sd(duree_totale_cumulee), 2),
    max = max(duree_totale_cumulee)
  )

print(summary_sejours_sexe)
```

Visualisation :

```{r}
ggplot(sejours_sexe, aes(x = Sexe, y = duree_totale_cumulee , fill = Sexe)) +
  geom_boxplot(alpha = 0.7) +
  # On limite l'affichage à 50 séjours pour que le graphique soit lisible
  # coord_cartesian(ylim = c(0, 50)) + 
  labs(
    title = "Nombre de séjours post-greffe par sexe",
    subtitle = "Zoom sur les patients (0 à 50 séjours)",
    x = "Sexe",
    y = "durée total de séjours"
  ) +
  theme_minimal()
```

Test Statistique (Mann-Whitney / Wilcoxon) Vu que les données sont très étalées

```{r}
wilcox.test(nb_sejours ~ Sexe, data = sejours_sexe)
```

Le test de Wilcoxon cherche à déterminer si la distribution du nombre de séjours est significativement différente entre les hommes et les femmes. Comme vous avez des valeurs très extrêmes (le patient à 3101 séjours), ce test est idéal car il ne se laisse pas influencer par ces "outliers" (valeurs aberrantes), contrairement à un test de moyenne classique.

Interprétation du test :

Le test de Wilcoxon compare la distribution du nombre de séjours entre les hommes et les femmes. Avec une p value de 0,003061, le test est pas significatif au seuil de 1 %. Cela signifie qu'il existe pune différence de comportement de suivi entre les deux sexes.


## Distribution de l’âge à la greffe par sexe

```{r}
summary_age_sexe <- data_patients %>%
  group_by(Sexe) %>%
  summarise(
    n = n(),
    age_moyen = mean(age_greffe, na.rm = TRUE),
    age_mediane = median(age_greffe, na.rm = TRUE),
    ecart_type = sd(age_greffe, na.rm = TRUE)
  )
print(summary_age_sexe)
```

Visualisation :

```{r}
ggplot(data_patients, aes(x = Sexe, y = age_greffe, fill = Sexe)) +
  geom_boxplot(alpha = 0.7) +
  labs(
    title = "Comparaison de l'âge des patients par sexe",
    subtitle = "Base agrégée (1 ligne par patient)",
    x = "Sexe",
    y = "Âge (années)"
  ) +
  theme_minimal()
```

Proposition de test statistique: t_test

```{r}
t.test(age_greffe ~ Sexe, data = data_patients)
```

Observation : Les hommes de l'échantillon sont en moyenne légèrement plus âgés que les femmes (environ 1,3 an de différence). Les médianes confirment cette tendance (56 ans pour les hommes contre 55 ans pour les femmes).

Résultat du test t :

Interprétation : La p-value est largement inférieure au seuil de 0,05. Cela signifie que la différence d'âge entre les hommes et les femmes est statistiquement significative.

Bien que la différence soit statistiquement réelle, elle reste de faible ampleur (moins de 2 ans). Cela peut suggérer que les hommes ont tendance à être greffés à un âge légèrement plus avancé que les femmes.

Voyons cela avec le calcul de l'état carré pour la puissance du test :


```{r}
library(effectsize)
t_to_eta2(t = 5.3954, df_error = 11993)
```

On voit bien la valeur de l'état carré très faible. D'où la confirmation de ce qu'on disait.

## Durée de suivi par âge

.forte dispersion des parcours de soins, quel que soit l'âge du patient

Pour l’ensemble des âges, la majorité des patients présente une durée cumulée de séjour relativement faible (souvent inférieure à 100 jours), tandis qu’un nombre restreint de patients connaît des durées nettement plus élevées, traduisant des parcours de soins complexes ou des complications post-greffe. Cette hétérogénéité est observable à tous les âges, y compris chez les patients jeunes.

tendance légèrement croissante de la durée totale de séjour avec l’âge : Toutefois, cette augmentation reste modérée et largement masquée par la variabilité interindividuelle très importante.

Biais éventuels :

**Censure temporelle des données :** BDD limitée à 2022. Les patients greffés en fin de période disposent mécaniquement d’un temps de suivi plus court =\> censure à droite de la durée.

**Durée de suivi variable selon les patients** Les patients plus anciens dans la base ont mécaniquement davantage d’opportunités d’accumuler des séjours, ce qui peut confondre l’effet de l’âge avec celui du temps d’observation.

```{r}

# Durée totale de séjour par patient (en jours)
duree_par_patient <- data %>%
  mutate(
    duree_sejour = as.numeric(fin_sejour - debut_sejour),
    duree_sejour = ifelse(duree_sejour <= 0, 1, duree_sejour)
  ) %>%
  group_by(study_id) %>%
  summarise(
    duree_totale = sum(duree_sejour, na.rm = TRUE),
    .groups = "drop"
  )

# Jointure avec l'âge à la greffe
duree_age <- duree_par_patient %>%
  left_join(
    data_patients %>% select(study_id, AGE_ANN),
    by = "study_id"
  )

summary(duree_age)


ggplot(duree_age, aes(x = AGE_ANN, y = duree_totale)) +
  geom_point(alpha = 0.3, color = "steelblue") +
  geom_smooth(
    method = "loess",
    se = FALSE,
    color = "red",
    linewidth = 1.2
  ) +
  coord_cartesian(ylim = c(0, 400)) +
  labs(
    title = "Durée totale de séjour post-greffe selon l’âge à la greffe",
    subtitle = "Axe des ordonnées limité à 1000 jours (meilleure lisibilité)",
    x = "Âge à la greffe (années)",
    y = "Durée totale de séjour (jours)"
  ) +
  theme_minimal()
```

test de spearman : suppose pas de relation linéaire ni de normalité (avec des valeurs extrêmes, censurée ou tronquée ? pas forcément normal)

```{r}
cor_spearman <- cor.test(
  duree_age$AGE_ANN,
  duree_age$duree_totale,
  method = "spearman",
  exact = FALSE
)

print(cor_spearman)

```

Afin de limiter ces biais, une **analyse complémentaire restreinte à une durée de suivi maximale de 100j post-greffe** sera réalisée. Cette approche permettra :

d’homogénéiser la fenêtre d’observation entre les patients,de réduire l’effet de la censure temporelle, et d’évaluer plus finement l’impact de l’âge sur l’intensité du suivi à court

```{r}
# Un séjour qui dépasse 100 jours est tronqué mais pas supprimé 
# Définition de la fenêtre de suivi (100 jours)
fenetre_100j <- 100

data_100j <- data %>%
  mutate(
    # Délai entre greffe et début du séjour
    delai_greffe_sejour = as.numeric(debut_sejour - date_greffe),

    # Fin théorique du suivi à 12 mois
    fin_suivi_100j = date_greffe + fenetre_100j,

    # Fin réelle du séjour tronquée à 100j
    fin_sejour_tronquee = pmin(fin_sejour, fin_suivi_100j),

    # Durée de séjour dans la fenêtre des 12 mois
    duree_sejour_100j = as.numeric(fin_sejour_tronquee - debut_sejour)
  ) %>%
  # Conserver uniquement les séjours qui commencent dans les 12 mois
  filter(delai_greffe_sejour >= 0 & delai_greffe_sejour <= fenetre_100j) %>%
  mutate(
    duree_sejour_100j = ifelse(duree_sejour_100j <= 0, 1, duree_sejour_100j)
  )

```

```{r}
duree_100j_par_patient <- data_100j %>%
  group_by(study_id) %>%
  summarise(
    duree_totale_100j = sum(duree_sejour_100j, na.rm = TRUE),
    .groups = "drop"
  )

# Jointure avec l'âge à la greffe
duree_age_100j <- duree_100j_par_patient %>%
  left_join(
    data_patients %>% select(study_id, AGE_ANN),
    by = "study_id"
  )

summary(duree_age_100j)

```

```{r}
duree_100j_par_patient <- data_100j %>%
  group_by(study_id) %>%
  summarise(
    duree_totale_100j = sum(duree_sejour_100j, na.rm = TRUE),
    .groups = "drop"
  )

# Jointure avec l'âge à la greffe
duree_age_100j <- duree_100j_par_patient %>%
  left_join(
    data_patients %>% select(study_id, AGE_ANN),
    by = "study_id"
  )

summary(duree_age_100j)

duree_100j_par_patient <- data_100j %>%
  group_by(study_id) %>%
  summarise(
    duree_totale_100j = sum(duree_sejour_100j, na.rm = TRUE),
    .groups = "drop"
  )

# Jointure avec l'âge à la greffe
duree_age_100j<- duree_100j_par_patient %>%
  left_join(
    data_patients %>% select(study_id, AGE_ANN),
    by = "study_id"
  )

summary(duree_age_100j)

```

```{r}
ggplot(duree_age_100j, aes(x = AGE_ANN, y = duree_totale_100j)) +
  geom_point(alpha = 0.3, color = "steelblue") +
  geom_smooth(
    method = "loess",
    se = FALSE,
    color = "red",
    linewidth = 1.2
  ) +
  coord_cartesian(ylim = c(0, 100)) +
  labs(
    title = "Durée totale de séjour post-greffe (≤ 100j) selon l’âge",
    subtitle = "Fenêtre de suivi homogène – lissage LOESS",
    x = "Âge à la greffe (années)",
    y = "Durée totale de séjour sur 100j"
  ) +
  theme_minimal()

```

```{r}
cor_spearman_100j <- cor.test(
  duree_age_100j$AGE_ANN,
  duree_age_100j$duree_totale_100j,
  method = "spearman",
  exact = FALSE
)

print(cor_spearman_100j)

```

```{r}

# Création des classes d'âge
duree_age_100j <- duree_100j_par_patient %>%
  left_join(
    data_patients %>% select(study_id, AGE_ANN),
    by = "study_id"
  ) %>%
  mutate(
    classe_age = cut(
      AGE_ANN,
      breaks = c(-Inf, 29, 39, 49, 59, 69, 79, Inf),
      labels = c("<30", "30-39", "40-49", "50-59", "60-69", "70-79", "≥80"),
      right = TRUE
    )
  )

# Vérifions un résumé
table(duree_age_100j$classe_age)

# Graphique : boxplot par classe d'âge
ggplot(duree_age_100j, aes(x = classe_age, y = duree_totale_100j)) +
  geom_boxplot(fill = "steelblue", alpha = 0.5, outlier.shape = NA) +
  #geom_jitter(width = 0.2, alpha = 0.3, color = "darkblue") +
  labs(
    title = "Durée totale de séjour post-greffe (≤ 12 mois) selon les classes d’âge",
    x = "Classe d’âge (années)",
    y = "Durée totale de séjour sur 12 mois (jours)"
  ) +
  theme_minimal()

```

Test de Kruskal–Wallis : distributions asymétriques, variances différentes, comparaison de \>2 groupes epsilon_carré = l’équivalent non paramétrique du R². `kruskal.test()` effectue le test de comparaison des distributions entre les classes d’âge. La statistique de Kruskal–Wallis (`H`) est transformée en **eta²** pour avoir un **indicateur de force d’association** entre la classe d’âge et la durée totale `eta2` varie entre 0 et 1 : plus elle est proche de 1, plus l’association est forte. `k` = nombre de classes d’âge, `n` = nombre total de patients.

```{r}
# Test de Kruskal-Wallis
kruskal_test <- kruskal.test(duree_totale_100j ~ classe_age, data = duree_age_100j)
kruskal_test

# Calcul de l'eta carré pour Kruskal-Wallis (taille d'effet)
# formule : eta2 = (H - k + 1) / (n - k), H = statistique du test, k = nb de groupes, n = taille totale
H <- kruskal_test$statistic
k <- length(unique(duree_age_100j$classe_age))
n <- nrow(duree_age_100j)
eta2 <- (H - k + 1) / (n - k)

eta2

```

## Diagnostic principal × âge

Dans la base de données, nous avons beaucoup de modalités par les diagnostics principaux. Dans l'optique d'avoir des résultats visibles, nous choisissons de prendre le top 5 juste pour l'analyse bivariée car en considérant toutes les modalités, nous obtenons pas de résultats interprétables.

Ajoutons d'abord les tranches d'âge dans data_patients

```{r}
data_patients <- data %>%
  group_by(study_id) %>%
  arrange(date_greffe) %>%
  slice(1) %>%
  ungroup() %>%
  mutate(
    # Votre code existant
    Sexe = factor(COD_SEX, levels = c(1, 2), labels = c("Masculin", "Féminin")),
    
    # L'ajout de la tranche d'âge
    tranche_age = cut(
      age_greffe,
      breaks = c(0, 30, 40, 50, 60, 70, 80, 120),
      labels = c("<30", "30-39", "40-49", "50-59", "60-69", "70-79", "≥80"),
      right = FALSE
    )
  )
```

Extraction du Top 5 des codes diagnostics par tranche d'âge

```{r}
top5_dgn_age <- data_patients %>%
  group_by(tranche_age, DGN_PAL_suivi) %>%
  summarise(effectif = n(), .groups = "drop") %>%
  # --- AJOUT ICI : On retire RSSABS ---
  filter(DGN_PAL_suivi != "RSSABS") %>% 
  # ------------------------------------
  group_by(tranche_age) %>%
  slice_max(order_by = effectif, n = 5, with_ties = FALSE) %>%
  ungroup()

print(top5_dgn_age)
```

Visualisation : graphique par facettes

```{r}
ggplot(top5_dgn_age, aes(x = reorder(DGN_PAL_suivi, effectif), y = effectif, fill = tranche_age)) +
  geom_col() +
  coord_flip() +
  facet_wrap(~tranche_age, scales = "free_y") +
  labs(
    title = "Top 5 des codes diagnostics principaux par tranche d'âge",
    x = "Code Diagnostic",
    y = "Nombre de patients"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

Interprétations : Le code **Z940** est l'étiquette dominante pour toutes les tranches d'âge. Les codes **Z512** et **Z291** complètent régulièrement le podium, montrant une certaine uniformité dans le codage des dossiers, peu importe l'âge.


Procédons maintenant à un test de chi-deux.

Réalisation du test du Chi-deux:

```{r}
# 1. Création de la table de contingence
table_dgn_age <- table(data_patients$tranche_age, data_patients$DGN_PAL_suivi)

# 2. Réalisation du test du Chi-deux
test_chi2 <- chisq.test(table_dgn_age)

# 3. Affichage du résultat
print(test_chi2)
```

Malgré une homogénéité visuelle nette des diagnostics dominants entre tranches d’âge (Z940 systématiquement majoritaire, suivi de Z512/Z491), le test du χ² conclut à une association statistiquement significative entre l’âge et le diagnostic principal. Cependant, l’avertissement de R indique que l’approximation du χ² est possiblement incorrecte en raison de nombreux effectifs attendus faibles (table très sparse). Dans ce contexte, la significativité est susceptible d’être amplifiée par la grande taille d’échantillon et le grand nombre de modalités diagnostiques. Ainsi, l’effet observé est vraisemblablement faible sur les diagnostics les plus fréquents, et davantage lié à des variations sur des diagnostics rares.


## Diagnostic principal × durée moyenne de séjour

```{r}
# Durée totale de séjour par patient (déjà cohérent avec ce que vous avez fait)
duree_par_patient <- data %>%
  mutate(
    duree_sejour = as.numeric(fin_sejour - debut_sejour),
    duree_sejour = ifelse(duree_sejour <= 0, 1, duree_sejour)
  ) %>%
  group_by(study_id) %>%
  summarise(
    duree_totale = sum(duree_sejour, na.rm = TRUE),
    .groups = "drop"
  )

# Jointure avec le diagnostic principal à la greffe
duree_diagnostic <- duree_par_patient %>%
  left_join(
    data_patients %>% select(study_id, DGN_PAL),
    by = "study_id"
  )

```

évite l'effet bruit et rend les résultats lisibles

```{r}
# Top 5 diagnostics principaux
top5_dgn <- data_patients %>%
  count(DGN_PAL, sort = TRUE) %>%
  slice_head(n = 5) %>%
  pull(DGN_PAL)

duree_diagnostic_top5 <- duree_diagnostic %>%
  filter(DGN_PAL %in% top5_dgn)

```

-   Moyenne \> médiane → asymétrie à droite

    Variabilité importante selon le diagnostic

    Justifie l’usage de tests non paramétriques

```{r}
table_duree_dgn <- duree_diagnostic_top5 %>%
  group_by(DGN_PAL) %>%
  summarise(
    n_patients = n(),
    duree_moyenne = round(mean(duree_totale), 1),
    duree_mediane = median(duree_totale),
    ecart_type = round(sd(duree_totale), 1),
    .groups = "drop"
  ) %>%
  arrange(desc(duree_moyenne))

print(table_duree_dgn)

```

```{r}
ggplot(duree_diagnostic_top5,
       aes(x = reorder(DGN_PAL, duree_totale, FUN = median),
           y = duree_totale)) +
  geom_boxplot(fill = "steelblue", alpha = 0.6, outlier.shape = NA) +
  coord_cartesian(ylim = c(0, 150)) +
  labs(
    title = "Durée totale de séjour post-greffe selon le diagnostic principal",
    subtitle = "Top 5 des diagnostics – niveau patient",
    x = "Diagnostic principal (CIM-10)",
    y = "Durée totale de séjour (jours)"
  ) +
  theme_minimal()

```

```{r}
kruskal_dgn <- kruskal.test(
  duree_totale ~ DGN_PAL,
  data = duree_diagnostic_top5
)

kruskal_dgn

```

```{r}
# Calcul de l'eta carré
H <- kruskal_dgn$statistic
k <- length(unique(duree_diagnostic_top5$DGN_PAL))
n <- nrow(duree_diagnostic_top5)

eta2_dgn <- (H - k + 1) / (n - k)
eta2_dgn

```

La durée totale de séjour post-greffe varie fortement selon le diagnostic principal à la greffe. Le graphique met en évidence une **augmentation progressive de la durée de séjour médiane et de la dispersion** en fonction des diagnostics, avec des profils de parcours très contrastés.

Les patients codés **Z940** et **Z512** présentent des durées de séjour globalement courtes et peu dispersées, traduisant des parcours de soins relativement simples et standardisés.\
À l’inverse, les diagnostics **RSSABS** et surtout **Z491** sont associés à des durées de séjour nettement plus longues, avec une variabilité très importante, suggérant des parcours plus complexes, probablement liés à des complications, des reprises chirurgicales ou un suivi médical intensif.

Le test de **Kruskal–Wallis** met en évidence une différence statistiquement significative entre les diagnostics principaux (p-value \< 0,05). La taille d’effet mesurée par l’eta carré (η² = 0,186) indique une **association forte** entre le diagnostic principal à la greffe et l’intensité du parcours de soins post-greffe. Autrement dit, près de **19 % de la variabilité de la durée totale de séjour** est expliquée par le diagnostic principal.

## Diagnostic × nombre de réhospitalisations

```{r}
data <- data %>%
  mutate(
    duree_sejour = as.numeric(fin_sejour - debut_sejour),
    duree_sejour = ifelse(duree_sejour <= 0, 1, duree_sejour)
  )

```

```{r}
# comptage des réhospitalisations 
rehosp_par_patient <- data %>%
  filter(duree_sejour > 1) %>%      
  group_by(study_id) %>%
  summarise(
    nb_rehospitalisations = n(),
    .groups = "drop"
  )

```

```{r}
# réintégration des patients sans réhospitalisation
rehosp_par_patient <- data_patients %>%
  select(study_id) %>%
  left_join(rehosp_par_patient, by = "study_id") %>%
  mutate(
    nb_rehospitalisations = ifelse(
      is.na(nb_rehospitalisations), 0, nb_rehospitalisations
    )
  )

# jointure avec le diagnoqtique principal 
rehosp_diagnostic <- rehosp_par_patient %>%
  left_join(
    data_patients %>% select(study_id, DGN_PAL),
    by = "study_id"
  )

# restrictions auw diagnistiques principaux les plus fréquents
top5_dgn <- data_patients %>%
  count(DGN_PAL, sort = TRUE) %>%
  slice_head(n = 5) %>%
  pull(DGN_PAL)

rehosp_diagnostic_top5 <- rehosp_diagnostic %>%
  filter(DGN_PAL %in% top5_dgn)

```

```{r}
# tableau descriptif
table_rehosp_dgn <- rehosp_diagnostic_top5 %>%
  group_by(DGN_PAL) %>%
  summarise(
    n_patients = n(),
    moyenne = round(mean(nb_rehospitalisations), 2),
    mediane = median(nb_rehospitalisations),
    ecart_type = round(sd(nb_rehospitalisations), 2),
    max = max(nb_rehospitalisations),
    .groups = "drop"
  ) %>%
  arrange(desc(moyenne))

print(table_rehosp_dgn)

```

```{r}
# graphique 
ggplot(rehosp_diagnostic_top5,
       aes(x = reorder(DGN_PAL, nb_rehospitalisations, FUN = median),
           y = nb_rehospitalisations)) +
  geom_boxplot(fill = "steelblue", alpha = 0.6, outlier.shape = NA) +
  coord_cartesian(ylim = c(0, 30)) +
  labs(
    title = "Nombre de réhospitalisations post-greffe (> 1 jour)",
    subtitle = "Durée calculée selon la définition du projet",
    x = "Diagnostic principal (CIM-10)",
    y = "Nombre de réhospitalisations"
  ) +
  theme_minimal()

```

```{r}
# test de kruskal wallis
kruskal_rehosp <- kruskal.test(
  nb_rehospitalisations ~ DGN_PAL,
  data = rehosp_diagnostic_top5
)

kruskal_rehosp

```

```{r}
# effet 
H <- kruskal_rehosp$statistic
k <- length(unique(rehosp_diagnostic_top5$DGN_PAL))
n <- nrow(rehosp_diagnostic_top5)

eta2_rehosp <- (H - k + 1) / (n - k)
eta2_rehosp

```

# Analyse des comorbilités 

# Préparation : joindre comorbidités à la durée cumulée

```{r}
# Base patient avec comorbidités (1 ligne/patient)
comorbidites_patient <- data %>%
  group_by(study_id) %>%
  slice(1) %>%
  ungroup() %>%
  select(
    study_id,
    diabete_r,
    diabete_insuline_r,
    HTA_r,
    AVC_r,
    syndrome_coronaire_r
  )

# Jointure avec la durée cumulée
duree_comorb <- bilan_par_patient %>%
  left_join(comorbidites_patient, by = "study_id")
```

# Diabète × durée totale cumulée
```{r}
data_diabete <- duree_comorb %>%
  filter(!is.na(diabete_r))
```


```{r}
data_diabete %>%
  group_by(diabete_r) %>%
  summarise(
    effectif = n(),
    moyenne = round(mean(duree_totale_cumulee), 1),
    mediane = median(duree_totale_cumulee),
    ecart_type = round(sd(duree_totale_cumulee), 1),
    max = max(duree_totale_cumulee)
  )
```

# Visualisation 
```{r}
ggplot(data_diabete, aes(x = diabete_r, y = duree_totale_cumulee, fill = diabete_r)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  coord_cartesian(ylim = c(0, 200)) +
  labs(
    title = "Durée totale cumulée selon le diabète",
    x = "Diabète",
    y = "Durée totale cumulée (jours)"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

# Test 
```{r}
wilcox.test(duree_totale_cumulee ~ diabete_r, data = data_diabete)
```

L’analyse met en évidence une différence significative de la durée totale cumulée de séjour post-greffe entre les patients diabétiques et non diabétiques. Le test non paramétrique de Wilcoxon montre que cette différence est statistiquement significative (p-value < 2.2e−16), indiquant que la distribution des durées de séjour diffère entre les deux groupes.

Cette observation suggère que le diabète est associé à un parcours de soins plus intensif après la greffe rénale, possiblement en raison d’un risque accru de complications, d’une surveillance médicale renforcée ou d’une prise en charge plus complexe.



## Diabète insulinodépendant × durée totale cumulée

```{r}
data_diabete_ins <- duree_comorb %>%
  filter(!is.na(diabete_insuline_r))

stats_diabete_ins <- data_diabete_ins %>%
  group_by(diabete_insuline_r) %>%
  summarise(
    effectif = n(),
    moyenne = round(mean(duree_totale_cumulee), 1),
    mediane = median(duree_totale_cumulee),
    ecart_type = round(sd(duree_totale_cumulee), 1),
    IQR = IQR(duree_totale_cumulee),
    max = max(duree_totale_cumulee)
  )

stats_diabete_ins
```

## Visualisation 
```{r}
ggplot(data_diabete_ins, aes(x = diabete_insuline_r, y = duree_totale_cumulee, fill = diabete_insuline_r)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA, color = "black") +
  coord_cartesian(ylim = c(0, 200)) +
  labs(
    title = "Durée totale cumulée selon le diabète insulinodépendant",
    subtitle = paste("n =", nrow(data_diabete_ins), "patients"),
    x = "Diabète insulinodépendant",
    y = "Durée totale cumulée (jours)"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```
# Test 

```{r}
test_diabete_ins <- wilcox.test(duree_totale_cumulee ~ diabete_insuline_r, data = data_diabete_ins)
test_diabete_ins
```

Les patients présentant un diabète insulinodépendant ont une durée cumulée de séjour significativement différente de celle des patients non insulinodépendants (Wilcoxon, p < 0,05), suggérant une complexité accrue du suivi post-greffe.



## AVC et durée totale cumulée

```{r}
data_AVC <- duree_comorb %>%
  filter(!is.na(AVC_r))

stats_AVC <- data_AVC %>%
  group_by(AVC_r) %>%
  summarise(
    effectif = n(),
    moyenne = round(mean(duree_totale_cumulee), 1),
    mediane = median(duree_totale_cumulee),
    ecart_type = round(sd(duree_totale_cumulee), 1),
    IQR = IQR(duree_totale_cumulee),
    max = max(duree_totale_cumulee)
  )

stats_AVC
```

# Visualisation
```{r}
ggplot(data_AVC, aes(x = AVC_r, y = duree_totale_cumulee, fill = AVC_r)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA, color = "black") +
  coord_cartesian(ylim = c(0, 200)) +
  labs(
    title = "Durée totale cumulée selon l’antécédent d’AVC",
    subtitle = paste("n =", nrow(data_AVC), "patients"),
    x = "AVC",
    y = "Durée totale cumulée (jours)"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```
# Test 
```{r}
test_AVC <- wilcox.test(duree_totale_cumulee ~ AVC_r, data = data_AVC)
test_AVC
```
Les patients présentant un antécédent d’AVC ont une durée cumulée de séjour significativement différente de celle des autres patients (Wilcoxon, p < 0,05), reflétant un suivi post-greffe potentiellement plus complexe.


## Syndrome coronaire × durée totale cumulée

```{r}
data_coronaire <- duree_comorb %>%
  filter(!is.na(syndrome_coronaire_r))

stats_coronaire <- data_coronaire %>%
  group_by(syndrome_coronaire_r) %>%
  summarise(
    effectif = n(),
    moyenne = round(mean(duree_totale_cumulee), 1),
    mediane = median(duree_totale_cumulee),
    ecart_type = round(sd(duree_totale_cumulee), 1),
    IQR = IQR(duree_totale_cumulee),
    max = max(duree_totale_cumulee)
  )

stats_coronaire
```

# Visualisation 

```{r}
ggplot(data_coronaire, aes(x = syndrome_coronaire_r, y = duree_totale_cumulee, fill = syndrome_coronaire_r)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA, color = "black") +
  coord_cartesian(ylim = c(0, 200)) +
  labs(
    title = "Durée totale cumulée selon le syndrome coronaire",
    subtitle = paste("n =", nrow(data_coronaire), "patients"),
    x = "Syndrome coronaire",
    y = "Durée totale cumulée (jours)"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

# Test
```{r}
test_coronaire <- wilcox.test(duree_totale_cumulee ~ syndrome_coronaire_r, data = data_coronaire)
test_coronaire
```

La présence d’un syndrome coronaire est associée à une différence significative de la durée totale cumulée de séjour post-greffe (Wilcoxon, p < 0,05), indiquant un impact potentiel de cette comorbidité sur le parcours de soins.